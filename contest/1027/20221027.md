# 同余方程 mod.cpp  mod.in  mod.out  1s  128M   

## 题目描述

求关于$ x$的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。

## 输入格式

一行，包含两个正整数 $a,b$，用一个空格隔开。

## 输出格式

一个正整数 $x_0$，即最小正整数解。输入数据保证一定有解。

## 样例 #1

### 样例输入 #1

```
3 10
```

### 样例输出 #1

```
7
```

## 提示

【数据范围】

对于 40%的数据，$2 ≤b≤ 1,000$；

对于 60%的数据，$2 ≤b≤ 50,000,000$；

对于 100%的数据，$2 ≤a, b≤ 2,000,000,000$。

# 天天爱跑步 running.cpp running.in running.out   2s     512M

## 题目描述

`小c` 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线,完成打卡任务。

这个游戏的地图可以看作一一棵包含 $n$ 个结点和 $n-1$ 条边的树，每条边连接两个结点,且任意两个结点存在一条路径互相可达。树上结点编号为从 $1$ 到 $n$ 的连续正整数。

现在有 $m$ 个玩家，第 $i$ 个玩家的起点为 $s_i$，终点为 $t_i$。每天打卡任务开始时，所有玩家在第 $0$ 秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。 (由于地图是一棵树，所以每个人的路径是唯一的)

`小c` 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 $j$ 的观察员会选择在第 $w_j$ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 $w_j$ 秒也正好到达了结点 $j$ 。`小c` 想知道每个观察员会观察到多少人?

注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一 段时间后再被观察员观察到。 即对于把结点 $j$ 作为终点的玩家：若他在第 $w_j$ 秒前到达终点,则在结点 $j$ 的观察员不能观察到该玩家；若他正好在第 $w_j$ 秒到达终点,则在结点 $j$ 的观察员可以观察到这个玩家。

## 输入格式

第一行有两个整数 $n$ 和 $m$。其中 $n$ 代表树的结点数量, 同时也是观察员的数量, $m$ 代表玩家的数量。

接下来 $n-1$ 行每行两个整数 $u$ 和 $v$，表示结点 $u$ 到结点 $v$ 有一条边。

接下来一行 $n$ 个整数，其中第 $j$ 个整数为 $w_j$ , 表示结点 $j$ 出现观察员的时间。

接下来 $m$ 行，每行两个整数 $s_i$，和 $t_i$，表示一个玩家的起点和终点。

对于所有的数据，保证 $1\leq s_i,t_i\leq n, 0\leq w_j\leq n$。

## 输出格式

输出 $1$ 行 $n$ 个整数，第 $j$ 个整数表示结点 $j$ 的观察员可以观察到多少人。

## 样例 #1

### 样例输入 #1

```
6 3
2 3
1 2 
1 4 
4 5 
4 6 
0 2 5 1 2 3 
1 5 
1 3 
2 6
```

### 样例输出 #1

```
2 0 0 1 1 1
```

## 样例 #2

### 样例输入 #2

```
5 3 
1 2 
2 3 
2 4 
1 5 
0 1 0 3 0 
3 1 
1 4
5 5
```

### 样例输出 #2

```
1 2 1 0 1
```

## 提示

【样例1说明】

对于 $1$ 号点，$w_i=0$，故只有起点为 $1$ 号点的玩家才会被观察到，所以玩家 $1$ 和玩家 $2$ 被观察到，共有 $2$ 人被观察到。

对于 $2$ 号点，没有玩家在第 $2$ 秒时在此结点，共 $0$ 人被观察到。

对于 $3$ 号点，没有玩家在第 $5$ 秒时在此结点，共 $0$ 人被观察到。

对于 $4$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $5$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $6$ 号点，玩家 $3$ 被观察到，共 $1$ 人被观察到。

【子任务】

每个测试点的数据规模及特点如下表所示。  
 提示: 数据范围的个位上的数字可以帮助判断是哪一种数据类型。

 ![](https://cdn.luogu.com.cn/upload/pic/3441.png) 

【提示】

如果你的程序需要用到较大的栈空间 (这通常意味着需要较深层数的递归), 请务必仔细阅读选手目录下的文本文档 running/stack.txt, 以了解在最终评测时栈空间的限制与在当前工作环境下调整栈空间限制的方法。

在最终评测时，调用栈占用的空间大小不会有单独的限制，但在我们的工作环境中默认会有 $1 \text{MiB}$ 的限制。 这可能会引起函数调用层数较多时， 程序发生栈溢出崩溃。

我们可以使用一些方法修改调用栈的大小限制。 例如， 在终端中输入下列命令
`ulimit -s 1048576`

此命令的意义是，将调用栈的大小限制修改为 $1 \text{GiB}$。

例如，在选手目录建立如下 sample.cpp 或 sample.pas


 ![](https://cdn.luogu.com.cn/upload/pic/3440.png) 

将上述源代码编译为可执行文件 sample 后，可以在终端中运行如下命令运行该程序

./sample

如果在没有使用命令“ ulimit -s 1048576”的情况下运行该程序， sample 会因为栈溢出而崩溃； 如果使用了上述命令后运行该程序，该程序则不会崩溃。

特别地， 当你打开多个终端时， 它们并不会共享该命令， 你需要分别对它们运行该命令。

请注意， 调用栈占用的空间会计入总空间占用中， 和程序其他部分占用的内存共同受到内存限制。

# 赛道修建  track.cpp track.in track.out    1s    512M 

## 题目背景

NOIP2018 提高组 D1T3

## 题目描述

C 城将要举办一系列的赛车比赛。在比赛前，需要在城内修建 $m$ 条赛道。 

C 城一共有 $n$ 个路口，这些路口编号为 $1,2,…,n$，有 $n-1$ 条适合于修建赛道的双向通行的道路，每条道路连接着两个路口。其中，第 $i$ 条道路连接的两个路口编号为 $a_i$ 和 $b_i$，该道路的长度为 $l_i$。借助这 $n-1$ 条道路，从任何一个路口出发都能到达其他所有的路口。 

一条赛道是一组互不相同的道路 $e_1,e_2,…,e_k$，满足可以从某个路口出发，依次经过 道路 $e_1,e_2,…,e_k$（每条道路经过一次，不允许调头）到达另一个路口。一条赛道的长度等于经过的各道路的长度之和。为保证安全，要求每条道路至多被一条赛道经过。 

目前赛道修建的方案尚未确定。你的任务是设计一种赛道修建的方案，使得修建的 $m$ 条赛道中长度最小的赛道长度最大（即 $m$ 条赛道中最短赛道的长度尽可能大）

## 输入格式

输入文件第一行包含两个由空格分隔的正整数 $n,m$，分别表示路口数及需要修建的 赛道数。 

接下来 $n-1$ 行，第 $i$ 行包含三个正整数 $a_i,b_i,l_i$，表示第 $i$ 条适合于修建赛道的道 路连接的两个路口编号及道路长度。保证任意两个路口均可通过这 $n-1$ 条道路相互到达。每行中相邻两数之间均由一个空格分隔。

## 输出格式

输出共一行，包含一个整数，表示长度最小的赛道长度的最大值。

## 样例 #1

### 样例输入 #1

```
7 1 
1 2 10 
1 3 5 
2 4 9 
2 5 8 
3 6 6 
3 7 7
```

### 样例输出 #1

```
31
```

## 样例 #2

### 样例输入 #2

```
9 3 
1 2 6 
2 3 3 
3 4 5 
4 5 10 
6 2 4 
7 2 9 
8 4 7 
9 4 4
```

### 样例输出 #2

```
15
```

## 提示

【输入输出样例 1 说明】 

所有路口及适合于修建赛道的道路如下图所示：     
![](https://cdn.luogu.com.cn/upload/pic/43162.png)    
道路旁括号内的数字表示道路的编号，非括号内的数字表示道路长度。 需要修建 $1$ 条赛道。可以修建经过第 $3,1,2,6$ 条道路的赛道（从路口 $4$ 到路口 $7$）， 则该赛道的长度为 $9 + 10 + 5 + 7 = 31$，为所有方案中的最大值。

【输入输出样例 2 说明】

 所有路口及适合于修建赛道的道路如下图所示：   
![](https://cdn.luogu.com.cn/upload/pic/43163.png)  
需要修建 $3 $条赛道。可以修建如下 $3 $条赛道： 
1. 经过第 $1,6 $条道路的赛道（从路口 $1$ 到路口$ 7$），长度为 $6 + 9 = 15$； 
2. 经过第$ 5,2,3,8$ 条道路的赛道（从路口$ 6$ 到路口 $9$），长度为 $4 + 3 + 5 + 4 = 16$；
3. 经过第 $7,4$ 条道路的赛道（从路口 $8$ 到路口$ 5$），长度为 $7 + 10 = 17$。 长度最小的赛道长度为 $15$，为所有方案中的最大值。 

### 数据规模与约定

所有测试数据的范围和特点如下表所示 :

| 测试点编号 |        $n$         |    $m$    | $a_i=1$ | $b_i=a_i+1$ | 分支不超过 $3$ |
| :--------: | :----------------: | :-------: | :-----: | :---------: | :------------: |
|    $1$     |      $\le 5$       |   $=1$    |   否    |     否      |       是       |
|    $2$     |      $\le 10$      | $\le n-1$ |   否    |     是      |       是       |
|    $3$     |      $\le 15$      | $\le n-1$ |   是    |     否      |       否       |
|    $4$     |     $\le 10^3$     |   $=1$    |   否    |     否      |       是       |
|    $5$     | $\le 3\times 10^4$ |   $=1$    |   是    |     否      |       否       |
|    $6$     | $\le 3\times 10^4$ |   $=1$    |   否    |     否      |       否       |
|    $7$     | $\le 3\times 10^4$ | $\le n-1$ |   是    |     否      |       否       |
|    $8$     | $\le 5\times 10^4$ | $\le n-1$ |   是    |     否      |       否       |
|    $9$     |     $\le 10^3$     | $\le n-1$ |   否    |     是      |       是       |
|    $10$    | $\le 3\times 10^4$ | $\le n-1$ |   否    |     是      |       是       |
|    $11$    | $\le 5\times 10^4$ | $\le n-1$ |   否    |     是      |       是       |
|    $12$    |      $\le 50$      | $\le n-1$ |   否    |     否      |       是       |
|    $13$    |      $\le 50$      | $\le n-1$ |   否    |     否      |       是       |
|    $14$    |     $\le 200$      | $\le n-1$ |   否    |     否      |       是       |
|    $15$    |     $\le 200$      | $\le n-1$ |   否    |     否      |       是       |
|    $16$    |     $\le 10^3$     | $\le n-1$ |   否    |     否      |       是       |
|    $17$    |     $\le 10^3$     | $\le n-1$ |   否    |     否      |       否       |
|    $18$    | $\le 3\times 10^4$ | $\le n-1$ |   否    |     否      |       否       |
|    $19$    | $\le 3\times 10^4$ | $\le n-1$ |   否    |     否      |       否       |
|    $20$    | $\le 5\times 10^4$ | $\le n-1$ |   否    |     否      |       否       |

其中，「分支不超过 $3$」的含义为：每个路口至多有 $3$ 条道路与其相连。

对于所有的数据，$2 \le n \le 5\times 10^4, \ 1 \le m \le n − 1,\ 1 \le a_i,b_i \le n,\  1 \le l_i \le 10^4$。



# 双栈排序  twostack.cpp twostack.in twostack.out  1s 50M

## 题目描述

Tom 最近在研究一个有趣的排序问题。如图所示，通过 $2$ 个栈 $S_1$ 和 $S_2$，Tom 希望借助以下 $4$ 种操作实现将输入序列升序排序。

 ![](https://cdn.luogu.com.cn/upload/pic/51.png) 

操作 $a$：将第一个元素压入栈 $S_1$。

操作 $b$：将 $S_1$ 栈顶元素弹出至输出序列。

操作 $c$：将第一个元素压入栈 $S_2$。

操作 $d$：将 $S_2$ 栈顶元素弹出至输出序列。


如果一个 $1\sim n$ 的排列 $P$ 可以通过一系列合法操作使得输出序列为 $(1,2,\cdots,n-1,n)$，Tom 就称 $P$ 是一个“可双栈排序排列”。例如 $(1,3,2,4)$ 就是一个“可双栈排序序列”，而 $(2,3,4,1)$ 不是。下图描述了一个将 $(1,3,2,4)$ 排序的操作序列：$\texttt {a,c,c,b,a,d,d,b}$。

 ![](https://cdn.luogu.com.cn/upload/pic/52.png) 

当然，这样的操作序列有可能有几个，对于上例 $(1,3,2,4)$，$\texttt{a,b,a,a,b,b,a,b}$ 是另外一个可行的操作序列。Tom 希望知道其中字典序最小的操作序列是什么。

## 输入格式

第一行是一个整数 $n$。

第二行有 $n$ 个用空格隔开的正整数，构成一个 $1\sim n$ 的排列。

## 输出格式

共一行，如果输入的排列不是“可双栈排序排列”，输出 `0`。

否则输出字典序最小的操作序列，每两个操作之间用空格隔开，行尾没有空格。

## 样例 #1

### 样例输入 #1

```
4
1 3 2 4
```

### 样例输出 #1

```
a b a a b b a b
```

## 样例 #2

### 样例输入 #2

```
4
2 3 4 1
```

### 样例输出 #2

```
0
```

## 样例 #3

### 样例输入 #3

```
3
2 3 1
```

### 样例输出 #3

```
a c a b b d
```

## 提示

$30\%$ 的数据满足：$n\le10$。

$50\%$ 的数据满足：$n\le50$。

$100\%$ 的数据满足：$n\le1000$。



