

Tree: 选两条路径的最大值有两种情况。第一种是选树直径，然后再把直径删除掉，再求一次直径。
第二种情况是，从直径的两端出发分别走到其它点。用BFS算法求最远点即可。

Reform: 定义S'[i]=min( i-j | j<i并且S[j]=S[i]  )，即S'[i]表示S[i]到上一次出现的距离。
容易发现，两个序列等价当且仅当他们这样转化之后是相同的。

这样我们就可以把主串和模式串都做这个变换，接下来就变成了普通的KMP问题

ball: 贪心。按照白云的喜爱度排序以后，白云每次会选择最靠前的球。
也就是说，白兔需要满足任何一个前缀，白兔选的球不能超过一半

先让白兔选择1,3,5,7,9..这些球，然后在此基础上进行调整，可以把前面的球替换为后面的球，用堆维护即可

Equation: 利用二次方程求根公式，有解当且仅当k^2-b是完全平方数。定义t^2=k^2-b，变成(k-t)(k+t)=b,令u=k-t,v=k+t，变成了询问有多少对(u,v)满足
奇偶性相同并且乘积在[P,Q]之间，利用根号分段进行计算即可