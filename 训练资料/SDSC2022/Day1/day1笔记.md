# Day1
## 一.优先队列

（实际上就是二叉堆

STL：priority_queue

1. 使用方法：重载运算符实现小根堆，最常用（dijkstra，最小生成树）

2. 堆的清空：一直弹出

3. 底层实现：   
    插入：一直和

    删除：将堆顶和孩子

## 二、单调队列

    “如果有人比你小还比你强，那你就可以退役了。”

基本原理：请领会上面的话

    eg1 P2216
    先横着跑每一行的单调队列，然后存在每一排的最右边，之后再从上往下跑单调队列得到二维的最大值和最小值的差

    eg2 P2034
    
    eg3 P3572
        用fi表示到i点的最小花费，那么i的花费必然由i-1/i-2/.../i-k加上一个cost得到（此题为1或0），然后用一个维护最小花费的单调队列维护前k个f极氪
        维护一个fj递增的单调队列，当高度相同时存比较靠后的那个

    eg4 P3957 
        提示：二分答案

## 三、栈
1. 栈是一种先进后出的数据结构

2. 单调栈
也是对于二维维护偏序，但是具体的进出栈方向不同。

    e.g.1 leetcode/trapping-rain-water

    向右跑一个单调栈，找到每一个元素向右第一个比它大的元素（排除0），之后根据元素的高度来计算阴影面积

    e.g.2 SP1805

    可以先在0位置加上一个高度为0的矩形，然后向右跑一个向右单增的单调栈，并在每一次弹出的时候计算形成的最大

    e.g.3 P3200

    讲个笑话，卡特兰数

3. 栈维护匹配问题

    e.g.1 一个兔子必须进一个洞，一个洞最多进一个兔子，兔子只能往右走，给出兔子和洞在数轴上的位置，最小化兔子行走的距离之和

    保证兔子数量小于等于洞的数量

    再讲个笑话，贪心即可

    e.g.1.2 把向左走去掉呢？
    
4. 维护右链辅助建树

e.g.笛卡尔树和虚树

(1) 笛卡尔树

笛卡尔树的元素有两维，一维为下表，二维为权值。其中权值按照堆的性质、下表按照二叉搜索树的性质成树。

    定义：二叉查找树，又被称为二叉搜索树。其特点如下：设x为二叉查找树中的一个结点，x节点包含关键字key，一句话就是左孩子比父节点小，右孩子比父节点大，还有一个特性就是中序遍历可以让结点有序。

笛卡尔树的栈构建：

## 四 ST表
1. 标准ST表

    略

2. 二维ST表

    e.g.理想正方形

## 五 STL的rope
1. rope的用法和vector类似，但是复杂度比较低。遗憾的是，CCF并不允许使用rope所在的命名空间，但偷着用可能不会被屏蔽（

    它的定义在#include<ext/rope>中，需要using namespace __gnu_cxx。

2. rope的基本操作有：
    
    x.length()/x.size() 返回x的大小

    x.push_back(s) 在末尾添加s

    x.insert(pos,s) 在pos位置插入s 

    x.erase(pos,x)  从pos位置开始删除x个

    x.replace(pos,s) 将位置为pos的元素换成s

    x.substr(pos,x) 从pos位置开始提取x个元素

    x.copy(pos,x,s) 将从pos位置开始x个元素提取到s中

    x.at(x)/[x]访问第x个元素

    这些操作复杂度都是1log。

        如果在插入的时候还想保持有序,我们只需用insert就可以实现.因为lower_bound函数能够返回迭代器,只需要在序列中lower_bound住x位置，在他后面插入即可。