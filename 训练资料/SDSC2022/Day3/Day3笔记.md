# Day3
## 一、还是并查集
### 1. 并查集的优化
接着昨天的来。
#### 1.1 路径压缩
```c++
return(fa[a]=find(fa[a]));
```
find函数这么写就行了。
#### 1.2 按秩合并
简单地说就是保证最大深度小的并查集连在深度比较大的并查集上，来保证树的平衡

    e.g.P1955


    e.g.2 P1196
    带权并查集模板题。
    祖先和后代的连边的权是可以表示意义的，我们可以权来表示战舰编号的差。
    在路径压缩的时候，边权也要随之改动。

    e.g.3 P1892（AC）
    扩展域并查集。
    朋友的朋友是朋友，进行一个并查集的合并；
    敌人的敌人是朋友，那么若A与B是敌人，那么A的敌人集合会和B的朋友集合合并，反之亦然。这里可以利用A+n来表示A的A的反集操作辅助统计
    计数时，统计根元素（fa[i]=i的元素）的数量即可。
    上午的那个食物链也是个类似的

### 2. 并查集的应用
#### （1）Kruskal算法求最小生成树
有模板力（
#### （2）Kruskal重构树（先说概念）
一个点并入联通块之前，先新建一个节点作为父节点，再将那个点与新建的父节点相连，如此一直构树。可以发现原图上的点都是叶子节点，同时边也可以记录一些数据。
#### （3）并查集的一些重要实例
##### e.g.1 

初始有n个孤立点编号1-n，接下来有m次加边操作，每次连接两个点。
设$f(u,v)$  表示点u,v 最早在第$f(u,v)$次操作后连通，m次操作后保证图连通，求$\sum_{u=1}^n \sum_{v=u+1}^n f(u,v)$

($n \le 10^5,m \le 2 \times 10^5$)

加上的边能不能改变联通性要用一个并查集来维护，并且计算每个点集的size，如果一条边连通了两个不连通的集合x，y，答案即加上$size_x \times size_y \times 当前操作次数$。
一次操作可以更新两个被联通的集合中的所有元素。

##### e.g.2
还是初始有n个孤立点编号1-n，接下来有m次加边操作，每次连接两个点

Q次询问，第i次询问点$x_i$ 在第$t_i$次操作后所在连通块大小

① 离线操作

询问按时间t排序，一边加边一边回答询问

② 强制在线

Kruskal重构树

点权显然向根是递增的。我们需要树上倍增找到最高的满足点权$\le t_i$的点，询问答案为子树叶子数。

（补充：Kruskal重构树的性质）

##### e.g.3
给定一个长为n的01序列$s_1,s_2,...s_𝑛$  ，初始全为0，需要支持一下操作:

修改：令$s_x$=1 

查询：给定x，查询$s_x,s_{x+1},...s_n$中从左数第一个0的位置

我们设$a_x$表示x右侧第一个0的位置，初始$a_x=x$
对于修改操作，我们需要使$a_x=a_{x+1}$，（将1合并）可以使用并查集来维护这个操作，并且路径压缩优化。时间复杂度O（nlogn）

##### e.g.4
给定3个长为n的序列a,b,c ，对于$1\le i \le j \le n$ ,求$a_i \times b_j \times \min_{(i \le k \le k)}c_k$的最大值。

初始我们假设序列为空，我们按c权值从大到小加入序列的点，
加入𝑐_𝑥  时序列中的c权值必然$\le c_x$  , 考虑以$c_x$  为 c 最小值的答案，即看看位置x连接着那些序列中现在存在的点，选取a，b的最大值更新答案。位置的连接可以用并查集维护，同时维护a，b最大值的信息。

## 二、二分图
### 1.定义
二分图可以被分成两个集合，且集合内部的元素之间没有连边

### 2.一些性质
（1）二分图不存在长度为奇数的环（每一个环
的结点数均是偶数）

（2）所以可以被两种颜色交替染色

### 3.判定方式
DFS/BFS对图进行黑白交替染色，染色成功就是一个二分图。

如果一个图是连通的，可以用如下的染色法判定是否二分图：

① 我们把X部的结点颜色设为0，Y部的颜色设为1;

② 从某个未染色的结点u开始，做BFS或者DFS 。把u染为0，枚举u的儿子v。如果v未染色，就染为与u相反的颜色，如果已染色，则判断u与v的颜色是否相同，若相同则不是二分图直接结束即可。

③ 如果一个图不连通，则在每个连通块中作判定。

    e.g.1.1330
    先判定二分图，不是二分图必然无解；
    之后黑白染色（其实判断的时候就染色了），之后看黑色的数量多还是白色的数量多，挑其中少的作为答案即可。

    e.g.2 P1525
    ① 二分答案
    令怒气值>mid的人分到不同集合，如果满足二分图，那么就调低mid，到不满足二分图为止

    ② 将关系按怨气值从大到小排序，显然我们应该先满足怨气值较大的问题，设这两个人是u,v，将这两个人分到不同集合意味着什么呢？我们可以联想到”敌人的敌人是朋友”逻辑传导，设点x是与x在相同集合的人，点x+n是与x在不同集合的人，u,v在不同集合即合并u和v+n，u+n和v，如果发现u，v已经同集合那么确定答案。

    e.g.3 P6185

## 三、单源次短路
类似Dijkstra，但是允许每个点被遍历2次，在第二次时既能确定次短路

## 四、欧拉回路
    通过图中所有边恰好一次的通路称为欧拉通路。
    通过图中所有边恰好一次的回路称为欧拉回路。(回到原点）
    有向图，无向图都有定义，但是混合图欧拉回路（有的边有向，有的无向，但是都只能经过一次）是复杂问题。
### 1.欧拉回路的判断
（1）图要联通（弱联通也可）

（2）对于无向图：

i. 若所有点的度数都为偶数，则存在欧拉回路；

ii. 若有且仅有2个（且一个图不可能只有一个）度数为奇数，则存在欧拉通路。

（3）对于有向图：

所有点入度=出度：存在欧拉回路；

恰有一个点出度-入度=1（起点）；恰有一个点入度-出度=1(终点）;其他点入度=出度：存在欧拉通路。

### 2.求一个图的欧拉路
Hierholzer 算法，即消圈算法。

    e.g.P2731

## 五、强联通分量（SCC）
### 1. Tarjan算法求强联通分量求解SCC

Tarjan算法对图进行dfs，形成dfs搜索树结构，分为以下几种边：

树边（树上的边）

返祖边（指向已经访问的点的边）

横叉边（横跨子树且指向了一个已访问过的节点的边）

前向边（）

对于每个点u维护以下变量：

（1）$dfn_u$：深度优先搜索遍历时结点u被搜索的次序

（2）$low_u$：能够回溯到的最早的**已经在栈中**的结点。即dfs树中u的子树中向上引反祖边能到的dfn最小的结点。

之后，
### 2.Tarjan的应用
我们可以将一张图的每个强连通分量都缩成一个点。

然后这张图会变成一个 DAG（有向无环图），可以进行拓扑排序以及更多其他操作。

    e.g.1
    求一条路径，可以经过重复结点，要求经过的不同结点数量最多。
    先用Tarjan对SCC进行一个缩点，得到一个DAG，每一个点包含一个size，用来表示SCC中的点的数量，然后开始DP。

    e.g.2 P1262
