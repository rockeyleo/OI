# 七 动态规划

即使你可以用各种暴力来骗取dp的分数，dp背后的思维仍旧十分重要。


## 线性DP

所谓线性dp,是指状态之间有线性关系的一类dp问题。

[动态规划初步·各种子序列问题 —皎月半洒花](https://www.luogu.com.cn/blog/pks-LOVING/junior-dynamic-programming-dong-tai-gui-hua-chu-bu-ge-zhong-zi-xu-lie)

###### e.g.1 [[洛谷P1216] [USACO1.5][IOI1994]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)

~~记忆化搜索~~

###### e.g.2 最长上升子序列（LIS）

首先明确一点，**子序列不一定是连续的。**

如果我们用`dp[i]`来表示**以i为结尾的序列的最大长度**，一开始将dp数组都初始化为1（一个以i为结尾的序列的长度至少为1，当这个数列只有它自己时），之后我们从数列的第一个数开始遍历，对于每一个`dp[i]`，遍历i前面的所有数字`num[j]`。如果`num[j]`满足`num[j]<num[i]`，那我们就试着把这个以j结尾的最长串后面直接接上i，来尝试更新以i结尾的最长序列长度。有`dp[i] = max(dp[i],dp[j]+1)`。

```C++
//from 皎月半洒花
for(int i=1;i<=n;i++){
    dp[i] = 1;
    for(int j=1;j<=i;j++){
        if(num[j]<num[i]){
            dp[i] = max(dp[i],dp[j]+1);
        }
    }
}
```

至于答案，应该是dp数组中元素的最大值，我们就有了一个$O(n^2)$的做法。

注意：因为`memset()`的工作原理，**不能使用`memset()`将数组初始化为1**，只有0x3f（表示的其实是0x3f3f3f3f/1061109567），0，-1（-1的补码恰好全是1）是较为安全的。

*优化？*

贪心地想，如果有两个长度相同的序列，那么我们一定先选结尾的数字小的那一个，以便于继续向后合并出更长的序列。由此我们可以产生一个新的思路：用`f[i]`来表示长度为i的子序列的最小末尾元素，`f[i]`可初始化为一个极大值。至于答案求解，统计最大的有效数组长度(不等于初值的就是有效的)，即为答案。也可以另f是一个vector容器，vector的`size()`即为答案。

来看看状态设计：

设原始序列为`num`，显然我们有`f[1]=a[1]`。因为我们的`f[i]`储存了长度为i的子序列的最小末尾值，所以显然`f[i+1]`表示的数列一定是由`f[i]`表示的数列加上一个数（这个数就是`f[i+1]`自己）转移而来的。按照子序列的单调性，一定有`f[i]<f[i+1]`，f数组满足单调性。所以，当我们从1到n遍历num数组的时候，设`x:{1->n}`，一旦遇到了一个比`f[cnt]`（一开始cnt=1）大的数，就暂时扩展f数组，令`f[++cnt]=num[x]`。如果这个数比`f[cnt]`要小，那么就往f数组的前面找，直到找到一个刚好比`num[x]`大的，用`num[x]`来更新数组f。这个过程我们可以使用`upeer_bound()`来实现。

这样做有什么好处呢？我们在寻找这个刚好比`num[x]`小的`f[n]`的时候，可以利用二分查找的方法在$O(\log n)$的时间内完成（upper_bound和lower_bound内部就是二分查找）。这样，算法的总体时间复杂度就被优化为$O(n\log n)$。

*延伸阅读：`lower_bound()/upper_bound()`的使用*

`lower_bound()`函数用于在指定区域内查找**不小于**目标值的第一个元素，一般用于查找最长不下降子序列，而`upper_bound()`则是查找**小于**目标值的第一个元素，一般用于求解最长上升子序列。这两个函数均需要三个参数：被查找序列的开头、结尾，以及要查找的元素。函数将会返回一个指针或迭代器（取决于使用数组还是vector），指向这个元素。

#### e.g.2.1 [[P1020][NOIP1999 普及]导弹拦截](https://www.luogu.com.cn/problem/P1020)

这个题的第一问求的是最长不上升子序列，做法类似，不再赘述；至于第二问，我们可以考虑贪心。

当我们需要拦截一个导弹的时候， 一定是优先选择大于导弹高度的拦截高度最矮的系统，来保证最大利用率。如果找到了，就更新系统的高度；如果找不到，就说明需要一套新的，并且新系统此时的高度就应为导弹的高度。二分代码写出来，其实就是在求序列的最长上升子序列。

还有一个我自己不成熟的思路：其实这个贪心的过程，和我们求LIS的nlogn做法不谋而合。显然，如果我们的每一套系统都在剩余的导弹中选择最长不下降子序列拦截，效率是最高的。并且，每一个最长不下降子序列，总是试图寻找一个最大的高度作为起始，所以似乎我们可以通过求最长上升子序列来得到需要的系统数量。它的正确性，与Dilworth定理紧密相连。Dilworth的定理内容是：

>**偏序集能划分成的最少的全序集个数等于最大反链的元素个数。** 
>->将一个序列剖成若干个单调不升子序列的最小个数等于该序列最长上升子序列的个数。

（[具体证明可看这篇博客](https://tofu.blog.luogu.org/pian-xu-ji-ha-si-tu-yu-dilworth-ding-li)）


###### e.g.3 [[洛谷P1439]最长公共子序列](https://www.luogu.com.cn/problem/P1439)（LCS）

状态设计：设原数列为A和B，我们用`dp[i][j]`来表示A串的前i位和第B串的前j位的LCS的长度，则不难得到：
- 若`A[i]=B[j]`，则`dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1)`
- 若`A[i]!=B[i]`，则考虑继承：`dp[i][j] = max(dp[i-1][j],dp[i][j-1])`

不过，$O(n^2)$的做法不足以通过此题。*有没有别的思路呢？*

您好，有的。对于两个序列A，B，如果我们给A重新编号，使其变成一个单调上升的序列A'，再用这些映射对B进行重编号，得到一个B'，我们就能惊喜地发现，B‘的所有上升子序列就都是A’的子序列了！也就是说，**我们只需要求B'的LIS就可以了**。以及显然，**这种转化只能适用于P1439这种规定了A，B序列均为为自然数 $1,2,\ldots,n$ 的一个排列“的题型**。因为只有在这个时候，A才能保证可以转化为一个单调序列。


## 背包九讲

~~典中典了属于是~~

[yxc背包九讲视频](https://www.bilibili.com/video/BV1qt411Z7nE/)

[背包九讲原文](https://www.cnblogs.com/jbelial/articles/2116074.html)

### 1. 01背包问题

#### 状态的表示

`f[i][j]` 用于表示只看前i个物品，总体积是j的情况下，总价值最大是多少

答案即为`max{f[n][0~v]}`

#### 状态转移

对于第i个物品：

- 不选第i个物品时，`f[i][j] = f[i-1][j]`
- 选第i个物品时，`f[i][j] = f[i-1][j-v[i]]+w[i]`

每次判断上两者哪个最大即可。

#### 初始化

`f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])`

`f[0][0] = 0`

#### 复杂度：$O\left(n^2 \right)$

#### code:

```C++
#include <bits/stdc++.h>
using namespace std;
int n,m;
int f[1001][1001];
int v[1001],w[1001];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>v[i]>>w[i];
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            f[i][j] = f[i-1][j];
            if(j >= v[i]){	//要保证背包剩余空间是足够的
                f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]);
            }
        }
    }
    int res = 0;
    for(int i=1;i<=m;i++)res = max(res,f[n][i]);
    cout<<res<<endl;
    return 0;
}
```

#### 优化：滚动数组

二维数组毕竟不能存储很大的数据，能不能用一个一维数组来表示呢？

如果我们把第一维去掉怎么样？

那么`f[i-1][j]`这一项没有区别，因为在`f[j]`被这一层循环的计算值覆盖之前，存的就是上一层的f[j]；但是`f[i-1][j-v[i]]`就不行了。原因是在第i层循环上，`f[i-1][j-v[i]]`比`f[i-1][j]`先算，表明我们使用`f[i-1][j-v[i]]`的时候，数据实际上已经被`f[i][j-v[i]]`覆盖了。所以，每一层的j我们都需要逆序查询。

而答案直接输出`f[m]`即可。

code：
```c++
#include <bits/stdc++.h>
using namespace std;
int n,m;
int f[1001];
int v[1001],w[1001];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>v[i]>>w[i];
    }
    for(int i=1;i<=n;i++){
        for(int j=m;j>=1;j--){
            f[j] = max(f[j],f[j-v[i]]+w[i]);
            }
        }
    }
    int res = 0;
    cout<<f[m]<<endl;
    return 0;
}
```

### 2. 完全背包问题

和01背包类似，但是每一个物品可以被选择多次

我们用01背包的思路，可以得到一个->$O\left(n^3\right)$的方程：

`f[i][j] = max(f[i-1][j-k*w[i]]+v[i]*k)`，k每个物品表示选择的数量（k可以为0）

#### *优化？*

不难发现，对于物品j，存在一个物品i，使得`c[i]<=c[j]`且`w[i]>=w[j]`，那么j是不用考虑的。不过，这样并不能降低最坏时间复杂度。

#### *接着优化？*

不妨用01背包的思路来解决。

对于每一件物品，最多也只能选择`v/c[i]`次，所以可以直接把一件可以选择多次的物品变成`v/c[i]`件01背包，这样就转化为了01背包问题。

但是复杂度还是没有变化。继续优化？

我们还可以利用二进制的思路，把第i种物品转化为费用为$c[i]\times 2^k$，价值为$w[i]\times 2^k$（$c\times 2^k\le V$）的若干件物品，这样物品就转化为了$O(]log(V/c[i]))$件物品，有了一点点优化。这个思路在多重背包里同样也会用到。

#### *能不能降低到$O(VN)$？*

对于状态`f[i][j]`，其实只要通过`f[i][j-w[i]]`转移就可以了。

怎样理解？

实际上这是在考虑

所以状态转移方程就变为`f[i][j] = max(f[i-1][j],f[i][j-w[i]]+v[i])`，我们成功得到了一个平方级别的解法。

#### *压缩成一维？*

既然有了二维方程，根据01背包问题的思路，不难想到，完全背包的代码其实就是01背包将里面的逆序转为正序就可以了。

```C++
#include <bits/stdc++.h>
using namespace std;
int n,m;
int f[1001];
int v[1001],w[1001];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>v[i]>>w[i];
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            f[j] = max(f[j],f[j-v[i]]+w[i]);
            }
        }
    }
    int res = 0;
    cout<<f[m]<<endl;
    return 0;
}
```

### 3. 多重背包问题

多重背包和完全背包的区别就是背包中的物品有数量的限制。用最朴素的思路，可以得到：`f[i][j] = max{f[i-1][v-k*c[i]] + k*[w[i]]}`，其中$0 \le k \le n[i]$

这样的复杂度是$O\left(V\sum n_i\right)$。

#### *优化？*

用上面提到的方法，不难将这个问题转化为一个01背包问题，变成一个有$\sum n_i$个物品的

继续优化也显而易见，就是二维拆分

我们用来表示

可以得到代码：

```c++
//(出自OIwiki)
index = 0;
for (int i = 1; i <= m; i++) {
  int c = 1, p, h, k;
  cin >> p >> h >> k;
  while (k - c > 0) {
    k -= c;
    list[++index].w = c * p;
    list[index].v = c * h;
    c *= 2;
  }
  list[++index].w = p * k;
  list[index].v = h * k;
}
```

#### *继续优化呢？*

考虑单调队列。参见下面的单调队列优化一节。

### 4. 混合背包问题

混合背包就是将前面的三种背包混合起来，有的物品能数一次，有的无限次，有的为1次。

### 5. 二维费用的背包问题

二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量），问怎样选择物品可以得到最大的价值。

设这两种代价分别为代价1和代价2，那么第i件物品所需的两种代价分别为`a[i]`和`b[i]` 。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i] 。

> 给出n个任务，完成每个任务需要t分钟和c元的开支，现在有T分钟时间，W元钱，求最多能完成多少任务。

可以在状态中再加一维，用来表示新的代价，所以我们易得：`f[i][v][u] = max(f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i])`

加上滚动数组优化，可以用一个二维数组解决。

注意好代码实现的循环顺序!

这种dp的复杂度一般是立方级别的，看数据范围应该挺好认

### 6. 分组背包问题

> 有$N$件物品和一个大小为$V$的背包，第$i$个物品的价值为$w_i$，费用为$c_i$，同时，这些物品被分为若干个组，同组内最多只能选择一个物品。求背包能装的最大总价值。

咋办捏？

其实就是01背包的「从在所有物品中选择一件」变成了「在每一组中选择一件」，于是对每一组进行一次01背包就可以了。

至于储存，可以用`t[i][j]`表示第k组的第i件物品的编号是多少，再用`cnt[k]`表示第k组的物品有多少个，然后在第二层循环里面加一个组遍历就可以了。

```C++
//from OIwiki C++ Version
for (int k = 1; k <= ts; k++)          // 循环每一组
  for (int i = m; i >= 0; i--)         // 循环背包容量
    for (int j = 1; j <= cnt[k]; j++)  // 循环该组的每一个物品
      if (i >= w[t[k][j]])
        dp[i] = max(dp[i],
                    dp[i - w[t[k][j]]] + c[t[k][j]]);  // 像0-1背包一样状态转移
```

### 7. 方案数问题

对于给定的一个背包容量、物品费用、其他关系等的问题，求装到一定容量的方案总数。

这个时候，我们用$dp_i$表示装到i时的方案数，然后把状态转移方程由最大值改成求和即可。有：$dp_i=\sum(dp_i,dp_{i-ci})$

### 8. 最优方案记录

#### 背包的最优方案数

#### 背包的第k优解


### 9. 有依赖的背包问题


其实从解决一系列背包问题的过程中就可以看出来，做dp的过程是一个不断优化的过程，推出一个初步答案有时候不难，但是想要得到最优复杂度则是一件需要更多思考的工作。


## DAG上的dp问题

一些实际问题中的二元关系可以用DAG来建模，从而将DAG转化为DAG上的最长路/最短路问题。

## 区间dp

区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的最优解进而得出整个大区间上最优解的dp算法。  

###### e.g.1. [P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)

题目包含了相邻的两个石子堆的合并操作，每次合并可以得到新的石子的和的得分，求你可以得到的最大得分。

我们令`f[i][j]`表示区间$[i,j]$内的所有石子合并到一起的最大得分。易得转移方程：$f[i][j]=\max\{f[i][k]+f[k+1][j]+\sum_{t=i}^ja_t\}~(i \le k \le j)$，显然第三项这个求和可以使用前缀和处理。 

因为$[i,k]$和$[k+1,j]$ 的长度一定比$[i,j]$的区间短，所以状态转移是从短的区间转移到长的区间 ，所以从短的递推至长的区间即可。

如何处理环呢？ 我们可以把环展开成一个2n长度的链，其中`a[i] = a[i+n]`，我们就能涵盖可能出现的所有情况。

递推处代码如下：

```C++
for(int len=1;len<=n;len++){
	for(int i=1;i<=2*n-1;i++){
		int j = len+i-1;
		for(int k=i;k<j and k<=2*n-1){
		//第二个区间是[k+1,j]，所以取k不取i，且k是有可能出界的
			f[i][j] = max(f[i][j],f[i][k]+[k+1][j]+(sum[j]-sum[i-1]))
		}
	}
}
```

注意：**答案应为$\max\{f[i][n],f[i+1][n+1],\dots ,f[n-1][2n-2]\}$，而不能仅仅考虑`f[i][j]`！**

###### e.g. P1063 能量项链
