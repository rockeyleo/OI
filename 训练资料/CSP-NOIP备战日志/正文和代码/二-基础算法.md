# 二 基础算法

## 模拟

扔点毒瘤（

[保证有一大堆你不知道的珂怕的码农题大集合 - 题单 - 洛谷](https://www.luogu.com.cn/training/3210#problems)

## 排序

### 归并排序与逆序对

虽然说归并排序本身可能不太会出现，但是其求解逆序对的功能还是比较重要的。 

## 二分答案

也从一个经典题目开始。

###### e.g.1 [[NOIP2015 提高组] 跳石头](https://www.luogu.com.cn/problem/P2678)

是怎么想到的二分答案呢？

~~还记得翰哥的一句名言：~~
> 给我算法标签我就能AC

两个重要特点：答案满足单调性、最大值最小/最小值最大

二分答案的思路源自于暴力搜索。我们可能很难找到一个合适的方法来判定删除这个最值出现的时候石头的分布应该满足什么性质，那就不妨从答案的角度出发，直接去优化搜索答案的过程。我们可以先假设一个答案是合法的，然后去判断这个时候需要满足的性质和题目要求是否冲突，如果冲突就换一个更大的答案（因为我们维护最小值），否则就尝试让这个最小值更大一点（对应最大化）。

对于本题，检验答案合法的方式是显然的。我们只需要把所有间距小于目标答案的石子移走就可以了，进行一次的复杂度是$O(n)$的。再加上log级的二分，整体的复杂度为$O(n\log n)$，可以通过此题。

从答案的角度出发，显然如果我们需要让最小值大一些，就需要多挪走一些石头，而挪走的石头一定满足一个特点，就是挪走前会出现一个区间，小于我们的目标答案，这是很好判定的。

#### 3. 更多例题

###### e.g.2 [[NOIP2015] 运输计划]

###### e.g.3 [关押罪犯]

这个题要求我们最小化一个最大值，容易想到二分。对于每一个答案，删除掉所有小于这个值的边权（因为这个时候它们都不可能成为最大值，对状态没有影响）之后判断图是否为一个二分图即可。如果是一个二分图，说明有更大冲突值的一对罪犯都可以被分在两个监狱中不见面，这个时候答案合法，二分查找即可。

本题也有一个并查集做法，在并查集一节会提到。

## 倍增

倍增法（英语：binary lifting），顾名思义就是翻倍。它能够使线性的处理转化为对数级的处理，大大地优化时间复杂度。

倍增的经典应用有ST表和求LCA两个，分别详见数据结构和图论两节。

### 例题

###### e.g.1 如何用尽量少的砝码称量出$[0,31]$之间的所有质量？

答案是使用1，2，4，8，16这五个砝码。如果我们只选择2的幂的质量，那么即使值域翻倍，我们也只需要增加一个砝码即可。

###### e.g.? 给定一棵树，多次询问一个点的$k$级祖先

常见写法：

```C++
int query(int a,int x){
	for(int i=0;(1<<i)<=x;i++){
		if((1<<i)&x)a = fa[a][i];
	}
	return a;
}
```


###### 变形：给定一棵树，多次询问一个点第一个子树大小$\ge k$的祖先

二者都是用同样的倍增，但可以发现第二个倍增的终止条件与当 前跳到的点有关，这个时候的倍增需要注意信息是否有单调性。

树上倍增的另一个常用领域是在$O(\log n)$的复杂度下求解树上两节点的最近公共祖先（LCA）。

## 高精度

## 构造

## 差分/前缀和

#### 1. 差分

#### 2. 前缀和

## 离散化

### 引入

设想我们需要处理一个数轴上的问题，虽然可能我们只需要处理几个端点，但是数轴的长度可能长得恼人，以至于利用常规的数据结构根本就不能处理。这个时候就需要离散化的思想来帮忙了。

离散化的本质算是一种哈希。既然我们完全不关心数轴本身的长度如何，那么完全可以之记录断点之间的相对大小关系，换掉原来不合理的数组下标，而原来的绝对位置则可以忽略。

| 原坐标   | 1222 | 335  | -3   | 12033000 | -1023910 |
| -------- | ---- | ---- | ---- | -------- | -------- |
| 离散化后 | 3    | 2    | 1    | 4        | 0        |

就像这样，我们在损失了一定信息的情况下， 把空间的跨度大大减少了。

### 离散化的实现

向您介绍：unique函数

unique函数的作用是去重，同时返回不同的数的数量。

设`a[i]`为原数组，长度为n，我们一般用`unique(1+a,1+a+n)-a-1`来表示离散化后数组的长度。

###### e.g. [洛谷P2070 刷墙](https://www.luogu.com.cn/problem/P2070) / [洛谷P2205 [USACO13JAN]Painting the Fence S](https://www.luogu.com.cn/problem/P2205)

这两个题其实只有一点微小区别，~~所以我也不知道为啥P2205就成蓝题了~~

> Bessie在她的行走中最远到达距起始点1,000,000,000个单位长度。

一看这个范围，知道要干啥了吧。

离散化之后，再来考虑怎么统计刷上的层数就可以了。可以用前缀和+查分的方法，但还能更粗暴一些：扫描线法。

这个技巧在这一并提一下，大概在线段树一节还会再提一下。

如果我们设一个端点为右界时记其为-1，为左界时记为1，这样扫到点时直接将这些标签相加，得到的就是此时的覆盖层数。

不难发现，如果一个点上同时有左标签和右标签，也不会对答案产生影响，并且先处理一个点上哪一个标签对结果没有影响。因为只有把同一个端点上的所有标签都处理完之后，答案才会有实质性的变化。

扫描线法是与离散化相辅相成的。

我们可以写出如下的扫描线代码：
```C++
int now = 0;
int ans = 0;
for(int i=1;i<=cnt-1;i++){
	now += node[i].opt;  //opt用于储存标签，左为1，右为-1
	if(now>=2)ans+=node[i+1].val-node[i].val;
	//l-r不加1可从样例中推得
}
```

进而可以得到AC代码：
```C++
#include <bits/stdc++.h>
using namespace std;
const int M = 100005;
struct nd{
    int val,opt;
}node[M*2];
int cnt = 0;
int main(){
    ios::sync_with_stdio(false);
    int n;
    cin>>n;
    int last = 0;
    for(int i=1;i<=n;i++){
        int tmp; char op;
        cin>>tmp>>op;
        if(op=='L'){
            tmp*=-1;
            node[++cnt]={last+tmp,1};  //1表示左界，-1表示右界
            node[++cnt]={last,-1};
        }else{
            node[++cnt]={last,1};
            node[++cnt]={last+tmp,-1};
        }
        last+=tmp;
    }
    sort(node+1,node+cnt+1,[](nd a,nd b){return a.val<b.val;});
    int now = 0;
    int ans = 0;
    for(int i=1;i<=cnt-1;i++){
        now += node[i].opt;
        if(now>=2)ans+=node[i+1].val-node[i].val;
    }
    cout<<ans<<endl;
}
```

至于P2205，只需要把最后一个循环中的`now>=2`改成`now>=k`就可以了，几乎没有什么不同。



## 贪心

~~不管对不对，贪就完事了~~

###### e.g.1 [P6033[NOIP2004提高] 合并果子](https://www.luogu.com.cn/problem/P6033)



其实贪心本身虽然具有目光短浅的问题，但是贪心思想往往十分常见。

两个例子：CSP2022T1假期计划、LIS的$O(n\log n)$做法