# 二 基础算法

## 模拟

扔点毒瘤（

[保证有一大堆你不知道的珂怕的码农题大集合 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/training/3210#problems)

## 二分答案

也从一个经典题目开始。

###### e.g.1 [[NOIP2015 提高组] 跳石头](https://www.luogu.com.cn/problem/P2678)

#### 1. 第一个问题：二分答案是什么？

#### 2. 更重要的问题：怎么想到的二分答案？

~~还记得翰哥的一句名言：~~

> 给我算法标签我就能AC

#### 3. 更多例题

###### e.g.2 [运输计划（NOIP2015）]


## 倍增

倍增法（英语：binary lifting），顾名思义就是翻倍。它能够使线性的处理转化为对数级的处理，大大地优化时间复杂度。

倍增的经典应用有ST表和求LCA两个，分别详见数据结构和图论两节。

### 例题

###### e.g.1 如何用尽量少的砝码称量出$[0,31]$之间的所有质量？

答案是使用1，2，4，8，16这五个砝码。如果我们只选择2的幂的质量，那么即使值域翻倍，我们也只需要增加一个砝码即可。

###### e.g.? 给定一棵树，多次询问一个点的$k$级祖先

###### 变形：给定一棵树，多次询问一个点第一个子树大小$\ge k$的祖先

二者都是用同样的倍增，但可以发现第二个倍增的终止条件与当 前跳到的点有关，这个时候的倍增需要注意信息是否有单调性。

## 高精度

## 构造

## 差分/前缀和

#### 1. 差分

#### 2. 前缀和

## 离散化

### 引入

设想我们需要处理一个数轴上的问题，虽然可能我们只需要处理几个端点，但是数轴的长度可能长得恼人，以至于利用常规的数据结构根本就不能处理。这个时候就需要离散化的思想来帮忙了。

离散化的本质算是一种哈希。既然我们完全不关心数轴本身的长度如何，那么完全可以之记录断点之间的相对大小关系，换掉原来不合理的数组下标，而原来的绝对位置则可以忽略。

| 原坐标   | 1222 | 335  | -3   | 12033000 | -1023910 |
| -------- | ---- | ---- | ---- | -------- | -------- |
| 离散化后 | 3    | 2    | 1    | 4        | 0        |

就像这样，我们在损失了一定信息的情况下， 把空间的跨度大大减少了。

### 离散化的实现

向您介绍：unique函数

unique函数的作用是去重，同时返回不同的数的数量。

设`a[i]`为原数组，长度为n，我们一般用`unique(1+a,1+a+n)-a-1`来表示离散化后数组的长度。

###### e.g. [洛谷P2070 刷墙](https://www.luogu.com.cn/problem/P2070) / [洛谷P2205 [USACO13JAN]Painting the Fence S](https://www.luogu.com.cn/problem/P2205)

这两个题其实只有一点微小区别

~~所以我也不知道为啥P2205就成蓝题了~~

> Bessie在她的行走中最远到达距起始点1,000,000,000个单位长度。

一看这个范围，知道要干啥了吧。

离散化之后，再来考虑怎么统计刷上的层数就可以了。可以用前缀和+查分的方法，但还能更粗暴一些：扫描线法。

这个技巧就不单独开栏了，在这一并提一下，大概在线段树一节还会再提一下。

如果我们设一个端点为右界时记其为-1，为左界时记为1，这样扫到点时直接将这些标签相加，得到的就是此时的覆盖层数。

不难发现，如果一个点上同时有左标签和右标签，也不会对答案产生影响，并且先处理一个点上哪一个标签对结果没有影响。因为只有把同一个端点上的所有标签都处理完之后，答案才会有实质性的变化。

扫描线法是与离散化相辅相成的。

我们可以写出如下的扫描线代码：
```C++
int now = 0;

int ans = 0;

for(int i=1;i<=cnt-1;i++){

now += node[i].opt;  //opt用于储存标签，左为1，右为-1
	if(now>=2)ans+=node[i+1].val-node[i].val;
	//l-r不加1可从样例中推得
}
```

进而可以得到AC代码：
```C++
#include <bits/stdc++.h>
using namespace std;
const int M = 100005;
struct nd{
    int val,opt;
}node[M*2];
int cnt = 0;
int main(){
    ios::sync_with_stdio(false);
    int n;
    cin>>n;
    int last = 0;
    for(int i=1;i<=n;i++){
        int tmp; char op;
        cin>>tmp>>op;
        if(op=='L'){
            tmp*=-1;
            node[++cnt]={last+tmp,1};  //1表示左界，-1表示右界
            node[++cnt]={last,-1};
        }else{
            node[++cnt]={last,1};
            node[++cnt]={last+tmp,-1};
        }
        last+=tmp;
    }
    sort(node+1,node+cnt+1,[](nd a,nd b){return a.val<b.val;});
    int now = 0;
    int ans = 0;
    for(int i=1;i<=cnt-1;i++){
        now += node[i].opt;
        if(now>=2)ans+=node[i+1].val-node[i].val;
    }
    cout<<ans<<endl;
}
```

至于P2205，只需要把最后一个循环中的`now>=2`改成`now>=k`就可以了，几乎没有什么不同。



## 贪心

~~不管对不对，贪就完事了~~

###### e.g.1 [P6033[NOIP2004提高] 合并果子](https://www.luogu.com.cn/problem/P6033)

